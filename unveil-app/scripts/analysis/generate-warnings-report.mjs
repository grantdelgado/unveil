#!/usr/bin/env node

import { readFileSync, writeFileSync, readdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '../..');

// Generate timestamp for file naming
const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 16);
const dateFormatted = new Date().toISOString().slice(0, 10).replace(/-/g, '');

const warningsDir = join(projectRoot, 'docs/reports/warnings');
const reportPath = join(projectRoot, 'docs/reports', `warnings_triage_${dateFormatted}.md`);
const csvPath = join(projectRoot, 'docs/reports', `warnings_triage_${dateFormatted}.csv`);

console.log('üìä Generating comprehensive warnings triage report...');

function main() {
  // Find the latest unified warnings file
  const unifiedFile = findLatestUnifiedFile();
  if (!unifiedFile) {
    console.error('No unified warnings file found. Please run unify-warnings.mjs first.');
    process.exit(1);
  }
  
  console.log(`Using unified warnings file: ${unifiedFile}`);
  
  // Load unified warnings data
  const warningsData = loadWarningsData(unifiedFile);
  
  // Generate markdown report
  const markdownReport = generateMarkdownReport(warningsData);
  writeFileSync(reportPath, markdownReport, 'utf8');
  
  // Generate CSV export
  const csvData = generateCSV(warningsData.warnings);
  writeFileSync(csvPath, csvData, 'utf8');
  
  console.log(`‚úÖ Warnings triage report generated:`);
  console.log(`   üìÑ Report: ${reportPath}`);
  console.log(`   üìä CSV: ${csvPath}`);
  
  // Print summary to console
  printExecutiveSummary(warningsData.summary);
  
  return {
    reportPath,
    csvPath,
    summary: warningsData.summary
  };
}

function findLatestUnifiedFile() {
  if (!existsSync(warningsDir)) {
    return null;
  }
  
  const files = readdirSync(warningsDir)
    .filter(f => f.startsWith('unified_') && f.endsWith('.json'))
    .sort()
    .reverse(); // Latest first
  
  return files.length > 0 ? join(warningsDir, files[0]) : null;
}

function loadWarningsData(filePath) {
  try {
    const content = readFileSync(filePath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.error('Failed to load warnings data:', error.message);
    process.exit(1);
  }
}

function generateMarkdownReport(data) {
  const { summary, warnings, timestamp, sourceFiles } = data;
  
  let report = `# Warnings Triage Report
*Generated on ${new Date(timestamp).toLocaleString()}*

## Executive Summary

| Metric | Count |
|--------|-------|
| **Total Warnings** | ${summary.total} |
| **P0 (Critical)** | ${summary.byPriority.P0} |
| **P1 (High)** | ${summary.byPriority.P1} |
| **P2 (Medium)** | ${summary.byPriority.P2} |

### Risk Assessment
${generateRiskAssessment(summary)}

### Tool Breakdown
${generateToolBreakdown(summary.byTool)}

---

## Top Risks (P0)

${generateTopRisks(warnings.filter(w => w.priority === 'P0'))}

---

## Priority Breakdown

### P0 - Critical Issues (${summary.byPriority.P0})
*Must fix immediately - potential production impact*

${generatePrioritySection(warnings.filter(w => w.priority === 'P0'))}

### P1 - High Priority (${summary.byPriority.P1})
*Should fix in current sprint - quality/performance impact*

${generatePrioritySection(warnings.filter(w => w.priority === 'P1'))}

### P2 - Medium Priority (${summary.byPriority.P2})
*Fix when convenient - maintenance/technical debt*

${generatePrioritySection(warnings.filter(w => w.priority === 'P2').slice(0, 10))}
${summary.byPriority.P2 > 10 ? `\n*... and ${summary.byPriority.P2 - 10} more P2 issues (see CSV for full list)*\n` : ''}

---

## Category Analysis

${generateCategoryAnalysis(summary.byCategory, warnings)}

---

## Action Playbook

${generateActionPlaybook()}

---

## Tool-Specific Findings

${generateToolSpecificFindings(summary.byTool, warnings)}

---

## Trends & Patterns

${generateTrendsAnalysis(warnings)}

---

## Appendices

### A. Data Sources
This report aggregated warnings from:
${sourceFiles.map(f => `- ${f}`).join('\n')}

### B. Methodology
- **Prioritization**: P0 ‚â•70 points, P1 ‚â•40 points, P2 <40 points
- **Scoring Factors**: Severity, category impact, frequency, file/route importance
- **Deduplication**: By tool + code + message + file + line
- **Classification**: Automated with manual review recommended

### C. Export Formats
- **Full CSV**: \`${csvPath.split('/').pop()}\`
- **JSON Data**: Available in \`docs/reports/warnings/\`

---

*Report generated by Unveil Warnings Triage System*
*Next suggested run: ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toLocaleDateString()}*`;

  return report;
}

function generateRiskAssessment(summary) {
  const total = summary.total;
  const p0Count = summary.byPriority.P0;
  const errorCount = summary.bySeverity.error || 0;
  
  let assessment = '';
  
  if (p0Count === 0 && errorCount === 0) {
    assessment = 'üü¢ **LOW RISK** - No critical issues detected';
  } else if (p0Count <= 3 && errorCount <= 5) {
    assessment = 'üü° **MEDIUM RISK** - Some critical issues require attention';
  } else {
    assessment = 'üî¥ **HIGH RISK** - Multiple critical issues need immediate action';
  }
  
  assessment += `\n\n**Key Concerns:**\n`;
  
  if (summary.byCategory.deprecation > 0) {
    assessment += `- ${summary.byCategory.deprecation} deprecation warnings (may break in future versions)\n`;
  }
  if (summary.byCategory.security > 0) {
    assessment += `- ${summary.byCategory.security} security-related warnings\n`;
  }
  if (summary.byCategory.perf > 0) {
    assessment += `- ${summary.byCategory.perf} performance warnings (bundle size/runtime)\n`;
  }
  if (summary.byCategory['type-any'] > 0) {
    assessment += `- ${summary.byCategory['type-any']} \`any\` type usage warnings\n`;
  }
  
  return assessment;
}

function generateToolBreakdown(byTool) {
  let breakdown = '| Tool | Count | Status |\n|------|-------|--------|\n';
  
  Object.entries(byTool).forEach(([tool, count]) => {
    const status = getToolStatus(tool, count);
    breakdown += `| ${tool} | ${count} | ${status} |\n`;
  });
  
  return breakdown;
}

function getToolStatus(tool, count) {
  if (count === 0) return '‚úÖ Clean';
  if (count <= 5) return 'üü° Few issues';
  if (count <= 20) return 'üü† Some issues';
  return 'üî¥ Many issues';
}

function generateTopRisks(p0Warnings) {
  if (p0Warnings.length === 0) {
    return '‚úÖ **No critical (P0) issues found!**\n\nAll warnings are P1 or lower priority.';
  }
  
  let risks = '';
  
  p0Warnings.slice(0, 10).forEach((warning, i) => {
    risks += `### ${i + 1}. ${warning.category.toUpperCase()}: ${warning.message.substring(0, 60)}...

**Tool:** ${warning.tool}  
**File:** ${warning.file || 'N/A'}  
**Route:** ${warning.route || 'N/A'}  
**Frequency:** ${warning.frequency}x  
**Owner:** ${warning.owner}  

**Recommended Action:**
${warning.action}

**Effort:** ${warning.effort} | **Impact:** ${warning.impact}

---

`;
  });
  
  return risks;
}

function generatePrioritySection(priorityWarnings) {
  if (priorityWarnings.length === 0) {
    return '*No warnings in this priority level.*\n';
  }
  
  // Group by category
  const byCategory = {};
  priorityWarnings.forEach(warning => {
    if (!byCategory[warning.category]) {
      byCategory[warning.category] = [];
    }
    byCategory[warning.category].push(warning);
  });
  
  let section = '';
  
  Object.entries(byCategory).forEach(([category, warnings]) => {
    section += `#### ${category.toUpperCase()} (${warnings.length})\n\n`;
    
    warnings.slice(0, 5).forEach(warning => {
      section += `- **${warning.tool}**: ${warning.message}\n`;
      section += `  - File: \`${warning.file || 'N/A'}\`\n`;
      if (warning.route) {
        section += `  - Route: \`${warning.route}\`\n`;
      }
      section += `  - Action: ${warning.action}\n\n`;
    });
    
    if (warnings.length > 5) {
      section += `  *... and ${warnings.length - 5} more ${category} warnings*\n\n`;
    }
  });
  
  return section;
}

function generateCategoryAnalysis(byCategory, warnings) {
  let analysis = '| Category | Count | Risk Level | Recommended Timeline |\n';
  analysis += '|----------|-------|------------|---------------------|\n';
  
  Object.entries(byCategory).forEach(([category, count]) => {
    const risk = getCategoryRisk(category, count);
    const timeline = getCategoryTimeline(category);
    analysis += `| ${category} | ${count} | ${risk} | ${timeline} |\n`;
  });
  
  analysis += '\n### Category Definitions\n\n';
  analysis += getCategoryDefinitions();
  
  return analysis;
}

function getCategoryRisk(category, count) {
  const highRiskCategories = ['security', 'deprecation', 'runtime'];
  const mediumRiskCategories = ['perf', 'react', 'type-any'];
  
  if (highRiskCategories.includes(category)) return 'üî¥ High';
  if (mediumRiskCategories.includes(category)) return 'üü† Medium';
  return 'üü° Low';
}

function getCategoryTimeline(category) {
  switch (category) {
    case 'security': return 'Immediate';
    case 'deprecation': return '1-2 sprints';
    case 'perf': return '2-3 sprints';
    case 'runtime': return '1-2 sprints';
    case 'react': return '1-3 sprints';
    case 'type': return '2-4 sprints';
    case 'a11y': return '1-2 sprints';
    case 'docs': return 'Next maintenance';
    default: return 'Backlog';
  }
}

function getCategoryDefinitions() {
  return `- **security**: Security vulnerabilities or unsafe patterns
- **deprecation**: APIs/features scheduled for removal
- **perf**: Performance issues (bundle size, runtime)
- **runtime**: Browser console errors/warnings
- **react**: React-specific warnings and errors
- **type**: TypeScript type issues and \`any\` usage
- **a11y**: Accessibility compliance issues
- **docs**: Documentation formatting and structure
- **lint**: Code style and linting issues
- **config**: Configuration and build setup warnings
- **other**: Miscellaneous warnings`;
}

function generateActionPlaybook() {
  return `### Next.js/Webpack Performance
- **Bundle size > 250KB**: Split into smaller chunks using \`dynamic()\`
- **Asset optimization**: Compress images, optimize fonts
- **Modular imports**: Use tree-shaking friendly imports

### TypeScript Issues
- **\`any\` types**: Add proper type definitions
- **Missing types**: Enable stricter TypeScript options
- **Type errors**: Review and fix type mismatches

### React Warnings
- **useEffect deps**: Add missing dependencies or use \`useCallback\`
- **Key props**: Add stable keys to list items
- **Hydration**: Ensure server/client markup matches

### ESLint Warnings
- **Autofix**: Run \`pnpm lint:fix\` for style issues
- **Custom rules**: Review deprecated API usage warnings
- **React hooks**: Fix dependency arrays and hook usage

### Deprecation Warnings
- **Check migration guides**: Review Next.js, React, Supabase docs
- **Timeline**: Plan migration before removal deadlines
- **Testing**: Thoroughly test after API changes

### Performance Monitoring
- **Bundle analyzer**: Use \`pnpm build:analyze\` for detailed analysis
- **Lighthouse**: Regular performance audits
- **Monitoring**: Set up alerts for bundle size regressions`;
}

function generateToolSpecificFindings(byTool, warnings) {
  let findings = '';
  
  Object.entries(byTool).forEach(([tool, count]) => {
    const toolWarnings = warnings.filter(w => w.tool === tool);
    const p0Count = toolWarnings.filter(w => w.priority === 'P0').length;
    
    findings += `### ${tool.toUpperCase()} (${count} warnings)\n\n`;
    
    if (p0Count > 0) {
      findings += `‚ö†Ô∏è **${p0Count} critical issues requiring immediate attention**\n\n`;
    }
    
    // Top issues for this tool
    const topIssues = toolWarnings
      .sort((a, b) => {
        const priorityOrder = { P0: 3, P1: 2, P2: 1 };
        return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
      })
      .slice(0, 3);
    
    if (topIssues.length > 0) {
      findings += '**Top Issues:**\n';
      topIssues.forEach((issue, i) => {
        findings += `${i + 1}. [${issue.priority}] ${issue.message.substring(0, 80)}...\n`;
      });
      findings += '\n';
    }
    
    findings += `**Recommended Next Steps:**\n${getToolRecommendations(tool)}\n\n`;
  });
  
  return findings;
}

function getToolRecommendations(tool) {
  switch (tool) {
    case 'next':
    case 'webpack':
      return '- Run bundle analyzer to identify large dependencies\n- Consider code splitting for heavy routes\n- Optimize image and font loading';
    case 'tsc':
      return '- Fix critical type errors first\n- Consider enabling stricter TypeScript options\n- Add type definitions for \`any\` usage';
    case 'eslint':
      return '- Run \`pnpm lint:fix\` for auto-fixable issues\n- Review and address deprecated API warnings\n- Update ESLint rules if needed';
    case 'playwright':
      return '- Fix browser console warnings\n- Check network request failures\n- Review runtime JavaScript errors';
    case 'vitest':
      return '- Update test dependencies if deprecated\n- Fix React warnings in tests\n- Review test environment setup';
    case 'mdlint':
      return '- Run markdownlint autofix\n- Update documentation formatting\n- Add missing alt text for images';
    case 'perf':
      return '- Address bundle size budget violations\n- Optimize large route chunks\n- Monitor performance regressions';
    default:
      return '- Review tool-specific documentation\n- Address high-priority warnings first\n- Monitor for recurring issues';
  }
}

function generateTrendsAnalysis(warnings) {
  const trends = {
    frequentFiles: getFrequentFiles(warnings),
    frequentMessages: getFrequentMessages(warnings),
    categoryDistribution: getCategoryDistribution(warnings)
  };
  
  let analysis = '### Frequent Problem Areas\n\n';
  
  if (trends.frequentFiles.length > 0) {
    analysis += '**Files with Multiple Warnings:**\n';
    trends.frequentFiles.forEach(({ file, count }) => {
      analysis += `- \`${file}\`: ${count} warnings\n`;
    });
    analysis += '\n';
  }
  
  if (trends.frequentMessages.length > 0) {
    analysis += '**Common Warning Patterns:**\n';
    trends.frequentMessages.forEach(({ pattern, count }) => {
      analysis += `- "${pattern}": ${count} occurrences\n`;
    });
    analysis += '\n';
  }
  
  return analysis;
}

function getFrequentFiles(warnings) {
  const fileCounts = {};
  
  warnings.forEach(warning => {
    if (warning.file) {
      fileCounts[warning.file] = (fileCounts[warning.file] || 0) + 1;
    }
  });
  
  return Object.entries(fileCounts)
    .filter(([, count]) => count > 2)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([file, count]) => ({ file, count }));
}

function getFrequentMessages(warnings) {
  const messageCounts = {};
  
  warnings.forEach(warning => {
    // Extract first 50 characters as pattern
    const pattern = warning.message.substring(0, 50);
    messageCounts[pattern] = (messageCounts[pattern] || 0) + 1;
  });
  
  return Object.entries(messageCounts)
    .filter(([, count]) => count > 1)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([pattern, count]) => ({ pattern, count }));
}

function getCategoryDistribution(warnings) {
  const distribution = {};
  warnings.forEach(warning => {
    distribution[warning.category] = (distribution[warning.category] || 0) + 1;
  });
  return distribution;
}

function generateCSV(warnings) {
  const headers = [
    'Priority', 'Tool', 'Category', 'Severity', 'Code', 'Message', 
    'File', 'Route', 'Line', 'Column', 'Frequency', 'Owner', 
    'Recommended Action', 'Effort', 'Impact'
  ];
  
  let csv = headers.join(',') + '\n';
  
  warnings.forEach(warning => {
    const row = [
      warning.priority,
      warning.tool,
      warning.category,
      warning.severity,
      warning.code || '',
      `"${warning.message.replace(/"/g, '""')}"`, // Escape quotes
      warning.file || '',
      warning.route || '',
      warning.location?.line || '',
      warning.location?.column || '',
      warning.frequency,
      warning.owner,
      `"${warning.action.replace(/"/g, '""')}"`,
      warning.effort,
      warning.impact
    ];
    
    csv += row.join(',') + '\n';
  });
  
  return csv;
}

function printExecutiveSummary(summary) {
  console.log('\nüìä Executive Summary');
  console.log('===================');
  console.log(`Total Warnings: ${summary.total}`);
  console.log(`P0 (Critical): ${summary.byPriority.P0}`);
  console.log(`P1 (High): ${summary.byPriority.P1}`);
  console.log(`P2 (Medium): ${summary.byPriority.P2}`);
  
  if (summary.byPriority.P0 > 0) {
    console.log('\nüö® CRITICAL ISSUES DETECTED - Immediate action required');
  } else if (summary.byPriority.P1 > 10) {
    console.log('\n‚ö†Ô∏è  HIGH PRIORITY BACKLOG - Schedule fixes this sprint');
  } else {
    console.log('\n‚úÖ Manageable warning levels');
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
